#include <cstdio>
#include <cstdlib>
#include <vector>
#include <getopt.h>
#include "cxx_extensions.hpp"
#include "instruction.hpp"
#include "interpreter.hpp"
#include "lexer.hpp"
#include "parser.hpp"
#include "utilities.hpp"

// Needed by the interpreter.
int trace_flag;

namespace {

int help_flag;
int dump_flag;

const option options[] = {
    {"help",  no_argument, &help_flag,  1},
    {"dump",  no_argument, &dump_flag,  1},
    {"trace", no_argument, &trace_flag, 1},
};

COLD void usage(const char* program_name) {
    std::fprintf(stderr,
            "Usage: %s [OPTION] FILE\n"
            "\n"
            "Options:\n"
            "  --help     Print this menu\n"
            "  --dump     Dump generated bytecode\n"
            "  --trace    Trace the execution (debug build only)\n",
            program_name);
}

COLD void dump(const std::vector<Instruction>& bytecode) {
    for (std::size_t i = 0; i < bytecode.size(); ++i) {
        std::printf("%08zu ", i);
        bytecode[i].print(stdout);
        std::putchar('\n');
    }
}

}

int main(int argc, char** argv) {
    const char* const program_name = argv[0];
    // Parse options.
    int opt;
    int opt_index;
    while ((opt = getopt_long_only(argc, argv, "", options, &opt_index))
            != -1) {
        switch (opt) {
        case 0:
            break;
        default:
            usage(program_name);
            return EXIT_FAILURE;
        }
    }
    if (help_flag != 0) {
        usage(program_name);
        return EXIT_FAILURE;
    }
#ifdef NDEBUG
    if (trace_flag != 0) {
        std::fputs("Trace flag can be only used in debug builds\n", stderr);
        return EXIT_FAILURE;
    }
#endif
    argc -= optind;
    argv += optind;
    if (UNLIKELY(argc != 1)) {
        usage(program_name);
        return EXIT_FAILURE;
    }
    // Open the source file.
    const char* const filename = argv[0];
    auto content = file_contents(filename);
    if (UNLIKELY(!content)) {
        std::fprintf(stderr, "Couldn't open the '%s' file\n", filename);
        return EXIT_FAILURE;
    }
    // Parse.
    Lexer lexer(content->c_str());
    Parser parser(std::move(lexer));
    parser.parse();
    if (dump_flag != 0) {
        dump(parser.bytecode());
        return EXIT_SUCCESS;
    }
    // Execute.
    return interpret(parser.bytecode(), parser.constants());
}
